{"meta":{"title":"三生石","subtitle":"记录生活","description":"","author":"贾兴磊","url":"http://example.com","root":"/"},"pages":[{"title":"“关于我”","date":"2020-10-17T15:39:27.000Z","updated":"2021-01-05T05:49:08.279Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"三生石！！！这些年我一直提醒自己一件事情，千万不要自己感动自己。大部分人看似的努力，不过是愚蠢导致的。什么熬夜看书到天亮，连续几天只睡几小时，多久没放假了，如果这些东西也值得夸耀，那么富士康流水线上任何一个人都比你努力多了。人难免天生有自怜的情绪，唯有时刻保持清醒，才能看清真正的价值在哪里。 ——于宙《我们这代人的困惑》 总爱瞎折腾，顺性单身直男。 Blog:Dan个人博客> qq:1271421134 Email:1271421134@qq.com> 希望好心情每天都照常营业"},{"title":"分类","date":"2020-10-16T13:58:58.000Z","updated":"2020-10-16T14:01:57.336Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-10-16T13:58:29.000Z","updated":"2020-10-16T14:00:01.354Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"我的小伙伴们","date":"2020-10-16T13:58:29.000Z","updated":"2021-01-13T03:54:56.602Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":"提交我的Blog资料 - name: 三生石 link: jiazhibo.top avatar:jiazhibo.top/img/tx.png descr: 梦想还是有的，就算是咸鱼，也要是最咸的那只。"},{"title":"图库","date":"2021-01-06T07:39:17.064Z","updated":"2021-01-06T07:39:17.064Z","comments":false,"path":"link/Gallery/index.html","permalink":"http://example.com/link/Gallery/index.html","excerpt":"","text":""},{"title":"自言自语","date":"2021-01-13T03:53:07.872Z","updated":"2021-01-13T03:53:07.872Z","comments":false,"path":"talking/index.html","permalink":"http://example.com/talking/index.html","excerpt":"","text":"12345678&lt;script type=&quot;text/javascript&quot; src=&quot;https://unpkg.com/artitalk&quot;&gt;&lt;/script&gt;&lt;div id=&quot;artitalk_main&quot;&gt;&lt;/div&gt;&lt;script&gt;new Artitalk(&#123; appId: &#x27;ixhmHx6xSYXYDAgkukDFfHhP-MdYXbMMI&#x27;, appKey: &#x27;mRe4bO94HcrRDr5829fVmkWE&#x27; ,&#125;)&lt;/script&gt; ​"}],"posts":[{"title":"在SpringBoot中使用Thymeleaf模板引擎","slug":"Thymeleaf","date":"2021-08-11T18:03:01.000Z","updated":"2021-08-07T12:29:57.937Z","comments":true,"path":"2021/08/12/Thymeleaf/","link":"","permalink":"http://example.com/2021/08/12/Thymeleaf/","excerpt":"","text":"在SpringBoot中使用Thymeleaf模板引擎 Springboot默认是不支持JSP的，默认使用thymeleaf模板引擎。 Thymeleaf 官网：https://www.thymeleaf.org/ 1、引入pom依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 2配置文件application.properties中配置123456spring.thymeleaf.cache=falsespring.thymeleaf.prefix=classpath:/templates/spring.thymeleaf.suffix=.htmlspring.thymeleaf.encoding=UTF-8spring.thymeleaf.content-type=text/htmlspring.thymeleaf.mode=HTML5 建议使用application.yaml 1234567spring: thymeleaf: cache: false encoding: UTF-8 mode: HTML5 prefix: classpath:/templates/ suffix: .html 3在resources/templates新建文件在resources/templates/这个文件目录下面新建HTML文件时，头文件要加上 1&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; 4th属性 th:text ：设置当前元素的文本内容，相同功能的还有th:utext，两者的区别在于前者不会转义html标签，后者会。优先级不高：order=7 th:value：设置当前元素的value值，类似修改指定属性的还有th:src，th:href。优先级不高：order=6 th:each：遍历循环元素，和th:text或th:value一起使用。注意该属性修饰的标签位置，优先级很高：order=2 th:if：条件判断，类似的还有th:unless，th:switch，th:case。优先级较高：order=3 th:insert：代码块引入，类似的还有th:replace，th:include，三者的区别较大，若使用不恰当会破坏html结构，常用于公共代码块提取的场景。优先级最高：order=1 th:fragment：定义代码块，方便被th:insert引用。优先级最低：order=8 th:object：声明变量，一般和*{}一起配合使用，达到偷懒的效果。优先级一般：order=4 th:attr：修改任意属性，实际开发中用的较少，因为有丰富的其他th属性帮忙，类似的还有th:attrappend，th:attrprepend。优先级一般：order=5","categories":[{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"http://example.com/categories/Thymeleaf/"}],"tags":[{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"http://example.com/tags/Thymeleaf/"},{"name":"StringBoot","slug":"StringBoot","permalink":"http://example.com/tags/StringBoot/"},{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"}]},{"title":"Redis","slug":"redis","date":"2021-08-02T18:16:20.000Z","updated":"2021-08-03T09:38:29.139Z","comments":true,"path":"2021/08/03/redis/","link":"","permalink":"http://example.com/2021/08/03/redis/","excerpt":"","text":"Redis命令 ping用来检查redis服务是否正常，如果返回pong表示redis服务正常 redis-cli keys * 查看所有的键 get keyname 通过key名来获取数据 数据类型string set key value 设置redis键值对，key表示键名，value表示键值对应的值 del key [key…] 删除指定的键 setex key second value 设置带过期时间的key以秒为单位。 ttl key 用来检查指定key的剩余时间 -1表示永不过期， -2表示不存在或者已经过期。 hash哈希 hmset key 字段名 值 [字段名 值….] key 下面可以管理一组键值对数据 hget key 字段 获取key下面指定的属性 hdel key 字段名 删除指定key下面的字段名 List列表 可以存储一组有序不唯一的数据 lpush key element…… 向列表中push多个数据，先push的在最后 lrange key start stop 查找指定区间内的元素 lindex key index 查找指定下标的元素 set集合 存储一组无序唯一的数据 sadd key element[elements…..] 返回受影响的行数 SMEMBERS key 查看集合中的数据 zset有序的set集合 zadd key 分数 成员[分数 成员…] key是当前集合的名字 分数为double类型的，成员不允许重复 redis会根据分数的大小来对成员进行排序，最小的在最前【分数允许重复】 Zrange key start stop 查找指定区间内的集合成员","categories":[{"name":"redis","slug":"redis","permalink":"http://example.com/categories/redis/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"SSM快速搭建","slug":"ssm","date":"2021-07-28T03:16:20.000Z","updated":"2021-07-28T03:06:33.556Z","comments":true,"path":"2021/07/28/ssm/","link":"","permalink":"http://example.com/2021/07/28/ssm/","excerpt":"","text":"SSM快速搭建1.SSM组成部分 Spring + SpringMVC + Mybatis 2.本教程基于idea和maven来实现ssm的搭建工作 1.开始：1.使用idea创建一个maven web项目。注意：一定要选取自己已经配置到的maven环境【带阿里云的】 2.检查项目结构是否正常，在控制台是否出现build success 字样，如果没有是为创建失败 3.找到项目的pom.xml (项目依赖管理文件)，在标签里加入&lt;spring.version&gt;4.0.6.RELEASE&lt;/spring.version&gt;，并写入以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-beanutils&lt;/groupId&gt; &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt; &lt;version&gt;1.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- c3p0 数据库连接池 start --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- c3p0 数据库连接池 end --&gt; &lt;!-- jsp-servlet支持 start --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;jstl-impl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jsp-servlet支持 end --&gt; &lt;!-- 标签库 start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.taglibs&lt;/groupId&gt; &lt;artifactId&gt;taglibs-standard-spec&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.taglibs&lt;/groupId&gt; &lt;artifactId&gt;taglibs-standard-impl&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 标签库 end --&gt; &lt;!-- apache的commons系列包 start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- apache的commons系列包 end --&gt; &lt;!-- apache 工具包 start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.xmlbeans&lt;/groupId&gt; &lt;artifactId&gt;xmlbeans&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- apache 工具包 end --&gt; &lt;!-- spring start --&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-websocket&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc-portlet&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-messaging&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-instrument-tomcat&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-instrument&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring start --&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis end --&gt; &lt;!--日志管理 start--&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;!--日志管理 end--&gt; &lt;!-- https://mvnrepository.com/artifact/javax.mail/mail --&gt; &lt;!--getter setter 注解 start--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--getter setter 注解 end--&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-core-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.ezmorph&lt;/groupId&gt; &lt;artifactId&gt;ezmorph&lt;/artifactId&gt; &lt;version&gt;1.0.6&lt;/version&gt; &lt;/dependency&gt;&lt;!-- todo 数据校验--&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.13.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.logging&lt;/groupId&gt; &lt;artifactId&gt;jboss-logging&lt;/artifactId&gt; &lt;version&gt;3.4.2.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;2.0.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!--json start--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.15&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.verson&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.verson&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--json end--&gt;&lt;!-- 分页page--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 4.找到pom.xml文件中的properties标签，并填入如下代码： 12&lt;spring.version&gt;4.0.6.RELEASE&lt;/spring.version&gt;&lt;jackson.verson&gt;2.8.7&lt;/jackson.verson&gt; 5.选中main文件夹 创建Java源文件和resources配置文件夹并将其对应成对应的类型 6.在Java源文件夹中创建如下包： cimmin(存放项目中所有的公共类，比如同意返回对象) dao（存放dao层接口，起名方式为‘Mapper.java’） service(存放项目中的所有业务逻辑接口) controller(控制层，负责调用service层来实现业务逻辑的调用) util(工具类，比如分页类，日期转换之类的工具) entity(实体类，主要负责MySQL中对应的字段和Java的属性一一对应) vo（view-object：视图对象，当页面中所需要的字段和实体类冲突时，可使用vo来解决） 7.在resource文件夹中创建如下内容 mappers(文件夹：存放所有的mapper的映射文件，这里的映射文件要与dao层接口一一对应) applicationContext.xml (spring - mybatis配置文件，主要负责全项目的注解扫描，对象创建等服务) applicationContext-mvc.xml (Springmvc 方向的配置文件，只要负责文件上传，视图解析) db.properties (数据库信息配置文件) logback.xml(日志记录配置文件) 8.编辑web.xml(全局最大的配置文件，在项目启动时候会优先加载此配置文件) ​ 1.跟换web.xml的头标签，因为2.3不支持el表达式 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;3.0&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;&gt; &lt;/web-app&gt; ​ 2写入一下代码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--监听上下文启动 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 配置springmvc 相关内容--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:applicationContext-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 配置过滤器，如果页面在传递数据时候乱码，配置这个--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;!-- 这里一定要写/*过滤器的所有请求 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 9配置applicationContext.xml内容 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- TODO 开启注解扫描--&gt; &lt;context:component-scan base-package=&quot;cn.kgc&quot; /&gt;&lt;!--引入配置文件--&gt; &lt;context:property-placeholder location=&quot;classpath*:db.properties&quot; /&gt;&lt;!-- 配置数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;/bean&gt;&lt;!--配置会话工厂 主要为dao层服务--&gt; &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot; &gt;&lt;!-- todo 配置会话工厂的数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;!-- 配置实体类的别名--&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;cn.kgc.ssm.entity&quot; /&gt;&lt;!-- todo 配置mapper映射文件的位置，这里同样采用固定位置来查找配置文件--&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:mapper/*Mapper.xml&quot; /&gt; &lt;/bean&gt;&lt;!--扫描dao层--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;cn.kgc.ssm.dao&quot; /&gt; &lt;/bean&gt;&lt;!--配置事务管理--&gt; &lt;bean class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot; &gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt;&lt;!-- todo 由于这次例子又没数据库增删改查操作,所以不写声明式事务--&gt;&lt;/beans&gt; 10配置applicationContext-mvc.xml内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;&lt;!-- todo 标志控制层--&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService2&quot;/&gt;&lt;!-- 开启注解扫描--&gt; &lt;context:component-scan base-package=&quot;cn.kgc&quot; /&gt;&lt;!-- 配置视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; &gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;!-- todo 配置静态资源--&gt; &lt;mvc:resources mapping=&quot;/statics/**&quot; location=&quot;/statics/&quot; /&gt;&lt;!-- todo 全局异常处理--&gt;&lt;!-- &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;--&gt;&lt;!--&amp;lt;!&amp;ndash; 配置错误信息的参数名称&amp;ndash;&amp;gt;--&gt;&lt;!-- &lt;property name=&quot;exceptionAttribute&quot; value=&quot;exception&quot; /&gt;--&gt;&lt;!--&amp;lt;!&amp;ndash; 配置展示错误信息的页面&amp;ndash;&amp;gt;--&gt;&lt;!-- &lt;property name=&quot;defaultErrorView&quot; value=&quot;error&quot; /&gt;--&gt;&lt;!-- &lt;/bean&gt;--&gt;&lt;!-- 配置date转化--&gt; &lt;bean class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot; id=&quot;conversionService2&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;bean class=&quot;cn.kgc.ssm.utils.DateConvert&quot; /&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt;&lt;!-- 文件上传配置--&gt; &lt;bean class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot; id=&quot;multipartResolver&quot;&gt;&lt;!-- 设置最大文件上传大小--&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;4096000000&quot; /&gt;&lt;!-- 设置文件编码格式--&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot; /&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;4096&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 至此所有的ssm配置工作完成 4项目中注解的解释 @Service 向spring容器中注入当前类为service层，用于service的实现类上 @Controller 相助当前类为控制层 @RequestMapping 这个注解比较厉害，可以修饰类也可以修饰方法，他的主要功能只要被标注，就说明可以接收请求和响应 @Resources 注入其他类，【这里特别容易空指针，请注意扫描内容】 @ResponseBody 表示当前方法返回的内容不走视图解析器 @RequestParam 主要用来接收奇纳丹传来的参数，负责当前端参数名称和后端参数名称不对应的情况，如果mvc中的一个参数被修饰了此注解，默认为必传项 @PathVariable 用户restful风格，从路径中获取参数","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://example.com/tags/SSM/"},{"name":"搭建","slug":"搭建","permalink":"http://example.com/tags/%E6%90%AD%E5%BB%BA/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://example.com/tags/Mybatis/"}]},{"title":"Java分页查询page类","slug":"javapage","date":"2021-07-02T06:26:00.000Z","updated":"2021-07-02T06:55:56.621Z","comments":true,"path":"2021/07/02/javapage/","link":"","permalink":"http://example.com/2021/07/02/javapage/","excerpt":"","text":"Java分页查询page1.创建page实现类和想要分页数据的实现类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class PageUtil &lt;T&gt;&#123; private Integer pageIndex; //页码 private Integer pageSize; //页容量 private Integer total; //总条数 private Integer totalPage; //总页数 private Integer beginIndex; //起始位置 private T rows; //数据集 public PageUtil(Integer pageIndex, Integer pageSize, Integer total) &#123; this.pageIndex = pageIndex; this.pageSize = pageSize; this.total = total; this.totalPage = total % pageSize == 0 ? total / pageSize : total / pageSize +1; this.beginIndex = (pageIndex -1)*pageSize; &#125; public Integer getPageIndex() &#123; return pageIndex; &#125; public void setPageIndex(Integer pageIndex) &#123; this.pageIndex = pageIndex; &#125; public Integer getPageSize() &#123; return pageSize; &#125; public void setPageSize(Integer pageSize) &#123; this.pageSize = pageSize; &#125; public Integer getTotal() &#123; return total; &#125; public void setTotal(Integer total) &#123; this.total = total; &#125; public Integer getTotalPage() &#123; return totalPage; &#125; public void setTotalPage(Integer totalPage) &#123; this.totalPage = totalPage; &#125; public Integer getBeginIndex() &#123; return beginIndex; &#125; public void setBeginIndex(Integer beginIndex) &#123; this.beginIndex = beginIndex; &#125; public T getRows() &#123; return rows; &#125; public void setRows(T rows) &#123; this.rows = rows; &#125;&#125; 想要分页的数据实现类 123456789101112131415161718192021222324252627282930313233343536373839public class NewsCategory &#123; private Long id; private String name; private Date createDate; @Override public String toString() &#123; return &quot;NewsCategory&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, createDate=&quot; + createDate + &#x27;&#125;&#x27;; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Date getCreateDate() &#123; return createDate; &#125; public void setCreateDate(Date createDate) &#123; this.createDate = createDate; &#125;&#125; 2.Dao层在Dao添加两个方法，分别是要获取数据的总数和一个分页的查询，也要在接口上添加。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*** * 获取新闻分类数量 * @return */ public Integer getTotal()&#123; getConnection(); String sql = &quot;select count(id) from news_category&quot;; Integer total = null; rs = executeQuery(sql , null); try &#123; while(rs.next())&#123; total = rs.getInt(&quot;count(id)&quot;); &#125; &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; close(); return total; &#125; /*** * 分页查询数据 * @param beginIndex 起始位置 * @param pageSize 页容量 * @return 符合条件的数据集 */ public List&lt;NewsCategory&gt; queryNewsPage(Integer beginIndex , Integer pageSize)&#123; getConnection(); String sql = &quot;select id,name,createDate from news_category limit ?,?&quot;; Object[] params = &#123;beginIndex,pageSize&#125;; rs = executeQuery(sql,params); List&lt;NewsCategory&gt; newsCategories = new ArrayList&lt;&gt;(); try &#123; while(rs.next())&#123; NewsCategory newsCategory = new NewsCategory(); newsCategory.setId(rs.getLong(&quot;id&quot;)); newsCategory.setName(rs.getString(&quot;name&quot;)); newsCategory.setCreateDate(rs.getDate(&quot;createDate&quot;)); newsCategories.add(newsCategory); &#125; &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; close(); return newsCategories; &#125; 3.service层service层添加一个方法，就是分页功能方法，参数是页码和页容量，接口添加。 1234567891011public PageUtil&lt;List&lt;NewsCategory&gt;&gt; page(Integer pageIndex, Integer pageSize)&#123; pageIndex = pageIndex == null ? 1:pageIndex; pageSize = pageSize == null ? 5 :pageSize; //查找条数 Integer total = newsCategoryDao.getTotal(); PageUtil&lt;List&lt;NewsCategory&gt;&gt; pageUtil = new PageUtil&lt;&gt;(pageIndex,pageSize,total); //开始分页查找 List&lt;NewsCategory&gt; newsCategories = newsCategoryDao.queryNewsPage(pageUtil.getBeginIndex(),pageUtil.getPageSize()); pageUtil.setRows(newsCategories); return pageUtil; &#125; 4测试1234567891011public class test1 &#123; public static void main(String[] args) &#123; NewsCategoryService newsCategoryService = new NewsCategoryServiceImpl(); PageUtil&lt;List&lt;NewsCategory&gt;&gt; page = newsCategoryService.page(1,3); System.out.println(&quot;总页数&quot;+page.getTotalPage()); System.out.println(&quot;当前页数据&quot;); for (NewsCategory row : page.getRows())&#123; System.out.println(row); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"page","slug":"page","permalink":"http://example.com/tags/page/"},{"name":"分页","slug":"分页","permalink":"http://example.com/tags/%E5%88%86%E9%A1%B5/"}]},{"title":"centos7安装MySQL5.7","slug":"LinuxAndMysql","date":"2021-06-29T08:40:20.000Z","updated":"2021-06-29T08:42:13.947Z","comments":true,"path":"2021/06/29/LinuxAndMysql/","link":"","permalink":"http://example.com/2021/06/29/LinuxAndMysql/","excerpt":"","text":"centos7安装MySQL5.7下载MySQL的安装引导 1wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm 安装MySQL安装引导 1yum -y install mysql57-community-release-el7-10.noarch.rpm 安装MySQL服务 1yum -y install mysql-community-server 启动MySQL服务 1systemctl start mysqld.service 检查MySQL状态 1systemctl status mysqld.service 获取MySQL密码 1grep &quot;password&quot; /var/log/mysqld.log 使用刚获得到的初始密码进入MySQL 修改用户密码 1ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new password&#39;; 允许用户远程访问 1grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;your password&#39; with grant option; #表示所有的主机都可以使用此账户登录，你也可以设定指定的IP地址 刷新权限 1flush privileges; 关闭防火墙 12systemctl stop firewalld.servicesystemctl status firewalld.service","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"安装","slug":"安装","permalink":"http://example.com/tags/%E5%AE%89%E8%A3%85/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"centos7","slug":"centos7","permalink":"http://example.com/tags/centos7/"}]},{"title":"JavaIO各种流的运用","slug":"JavaIO","date":"2021-04-20T18:16:20.000Z","updated":"2021-05-18T06:50:43.648Z","comments":true,"path":"2021/04/21/JavaIO/","link":"","permalink":"http://example.com/2021/04/21/JavaIO/","excerpt":"","text":"IO操作 输入输出：站在程序角度，输入(Input)-读, 输出(Ouput)-写 使用FIle类操作文件或者目录 File类的常见方法 方法名 说明 boolean exists() 判断文件或者目录是否存在 boolean isFile() 判断是否是文件 boolean isDirectory() 判断是否是目录 String getPath() 返回此对象表示的文件的相对路径 String getAbsolutePath() 返回此对象表示的文件的绝对路径名 String getName() 返回此对象表示的文件或者目录的名称 boolean delete() 删除此对象指定的文件或目录 boolean createNewFile() 创建名称的空文件，不创建文件夹 long leng() 返回文件的长度，的那位为字节，如果文件不存在返回OL 使用字节流读写文本文件字节输入流(读文件)：InputStream-FileInputStream-read() FileInputSream对象的read()方法有两种方法：read()=======read(byte[]) 123456789101112131415161718192021222324252627282930313233343536373839404142public class test &#123; public static void main(String[] args) &#123; //todo 首先要引入资源 //创建file对象写入相应路径 File file = new File(&quot;d:/mary/demo.txt&quot;); //创建FileInputStream对象，先把它设置为null，以便在结束时候关闭。 FileInputStream fileInputStream = null; try &#123; // TODO 创建FileInputStream对象，把file对象路径赋值给FileInputStream对象，也可以赋值给一个路径。 fileInputStream = new FileInputStream(file); // todo 借助FileInputStream对象的read()方法来读取文件,read()这个方法要抛出异常 // 方法1，使用read()// int data; //读取到的每个字节的整数表示形式// while((data = fileInputStream.read()) != -1)&#123;// //把data这个int类型转换成char类型才能看到字符// System.out.print((char)(data));// &#125; //方法2，使用read(byte[]) byte[] bytes = new byte[1024]; int d; while((d = fileInputStream.read(bytes)) != -1)&#123; for (int i = 0; i&lt;d; i++)&#123; System.out.print((char)bytes[i]); &#125; &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; try &#123; //todo 结束后必须close关闭流，节省资源，close（）也会有异常 fileInputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 字节输出流(写文件)OuputSteam-FileOutStream-write() FileOutputStream这个类有两个构造，个是只添加路径或者file对象，另一个是还可以追加一个true，意思就是在原有的内容上添加新内容。 FileOutputStream写入方法 write(byte[])=====write(byte[] ,int off int len); 12345678910111213141516171819202122232425262728293031323334public class TestFileOutputStream &#123; public static void main(String[] args) &#123; // todo 1首先引入资源， // 创建file实例 File file = new File(&quot;d:/mary/demo.txt&quot;); // todo 2创建FileOutputStream这个对象实例，写在外部方便关闭流 FileOutputStream fileOutputStream = null; try &#123; // 把file这个对象传进fileOutputStream实例 //fileOutputStream = new FileOutputStream(file); // todo FileOutputStream这个类有两个构造，一个是只添加路径或者file对象，另一个是还可以追加一个true，意思就是在原有的内容上添加新内容 fileOutputStream = new FileOutputStream(file,true); //创建一个String变量， String str = &quot;好好学习，天天向上呀&quot;; //把这个String类型变量变成字节， byte[] strs = str.getBytes(); // todo 3使用FileOutputStream的write这个方法把byte字节类型的变量写入文件 fileOutputStream.write(strs,0,strs.length); System.out.println(&quot;ok啦&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; try &#123; // todo 4最后使用完这个流，使用close()方法关闭流 fileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 使用字符流读写文本文件Reder类是是字符输入流的基类-抽象类 字符输入流Rader-InputStreamReader-FileReader-BufferedReader FileReaderFileReader是Reader类的孙子 FileReader(File file) ==== FileReader(String name) 1234567891011121314151617181920212223242526272829public class TestFileReader &#123; public static void main(String[] args) &#123; // todo 1引入资源 FileReader fileReader = null; try &#123; // todo 2创建FileReader对象 fileReader = new FileReader(&quot;D:/mary/demo.txt&quot;); StringBuffer stringBuffer = new StringBuffer(); char[] bytes = new char[1024]; int i ; // todo 调用FileReader对象的read方法来读取文件 while((i = fileReader.read(bytes)) != -1)&#123; stringBuffer.append(bytes); &#125; System.out.println(stringBuffer); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; try &#123; // todo 最后使用FileReader的close()方法关闭流 fileReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; InputStreamReaderInputStream是reader的子类 它在创建实例时，要传进一个FileInputStream类，还可以指定编码格式 InputStreamReader(InputStream in)======InputStreamReader(InputStream in , String charsetName) 此类和FileReader一样，就是在创建时候穿的参数不同 获取本地平台的字符编码 1System.out.println(System.getProperty(&quot;file.encoding&quot;)); BufferedRederBufferedReader是Reader的子类，创建实例时，传进Reader类，它是带有缓冲区的字符输入流，按行读取文件，提高了文件读取效率。 构造方法：BufferedReader(Reader in) 方法：readLine() 123456789101112131415161718192021222324252627282930public class TestBufferedReader &#123; public static void main(String[] args) &#123; FileInputStream fileInputStream = null; InputStreamReader inputStreamReader = null; BufferedReader bufferedReader = null; try &#123; fileInputStream = new FileInputStream(&quot;d:/mary/demo.txt&quot;); inputStreamReader = new InputStreamReader(fileInputStream,&quot;utf-8&quot;); bufferedReader = new BufferedReader(inputStreamReader); String s = null; while((s = bufferedReader.readLine()) != null)&#123; System.out.println(s); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; try &#123; bufferedReader.close(); inputStreamReader.close(); fileInputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 关闭流时，后开先关 字符输出流Writer类是字符输出流的基类-抽象类 Writer-OutpusStreamWriter-FileWriter-BufferedWriter FileWriter构造方法：FileWriter(File file)====FileWriter(String name) ,加Boolean的true是在原有文件追加文件 常用方法： write(String str)====write(String str, int off, int len)====void close()====void flush() 12345678910111213141516171819public class TestFileWrite &#123; public static void main(String[] args) &#123; FileWriter fileWriter = null; try &#123; fileWriter= new FileWriter(&quot;d:/mary/demo.txt&quot;); String str = &quot;Holle,world!!!&quot;; fileWriter.write(str); fileWriter.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; fileWriter.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; OutpusStreamWriter构造： OutputStreamWriter(OutputStream out)==== OutputStreamWriter(OutputStream out ，String charsetName) 创建这个实例时候可以指定字符编码格式，代码和FlieWrirer一样。 BufferedWriterBufferedWriter是Writer类的子类，它带有缓冲区。 构造： BufferedWriter(Writer out) 方法：write()====newLine()===fllush() 123456789101112131415161718192021222324252627282930public class TestBufferedWriter &#123; public static void main(String[] args) &#123; FileOutputStream fileOutputStream = null; OutputStreamWriter outputStreamWriter = null; BufferedWriter bufferedWriter = null; try &#123; fileOutputStream = new FileOutputStream(&quot;d:/mary/demo.txt&quot;); outputStreamWriter = new OutputStreamWriter(fileOutputStream,&quot;utf-8&quot;); bufferedWriter = new BufferedWriter(outputStreamWriter); bufferedWriter.write(&quot;哈哈哈哈&quot;); bufferedWriter.newLine(); bufferedWriter.write(&quot;我是第二行&quot;); bufferedWriter.flush(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; try &#123; bufferedWriter.close(); outputStreamWriter.close(); fileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 使用字节流读写二进制文件DataOutputStream、DataInputStream DataOutputStream传参是FileOutputStream,DataInputStream传参是FileInputStream 其方法跟这两个是一样的。 1234567891011121314151617181920212223242526272829303132333435public class TestDataInputAndOutput &#123; public static void main(String[] args) &#123; FileInputStream fileInputStream = null; DataInputStream dataInputStream = null; FileOutputStream fileOutputStream = null; DataOutputStream dataOutputStream = null; try &#123; fileInputStream = new FileInputStream(&quot;d:/mary/myimg.jpg&quot;); dataInputStream = new DataInputStream(fileInputStream); fileOutputStream = new FileOutputStream(&quot;d:/mary/myqi.jpg&quot;); dataOutputStream = new DataOutputStream(fileOutputStream); int tepe; while ((tepe = dataInputStream.read()) != -1)&#123; dataOutputStream.write(tepe); &#125; System.out.println(&quot;复制完毕&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; try &#123; dataInputStream.close(); fileInputStream.close(); dataOutputStream.close(); fileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 使用序列化和反序列化保持和恢复对象信息ObjectOutputStream-序列化 ObjectInputStream-反序列化 在序列化对象时候，必须要把类实现Serializable接口。否则会抛出NotSerializableException异常 在反序列化对象时候，要把反序列化出来的对象强转成你自己定义的类。 在序列化和反序列化时候如果不希望某个成员变量被序列化时，可以加入transient这个关键字可以不被反序列化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class StudentTest &#123; public static void main(String[] args) &#123; Student stu = new Student(1,&quot;Mary&quot;,&quot;地球村&quot;); //StudentTest.serialize(&quot;d:/Student.txt&quot;,stu); StudentTest.deserialization(&quot;d:/Student.txt&quot;); &#125; public static void serialize(String Path , Student stu)&#123; File file = new File(Path); FileOutputStream fos = null; ObjectOutputStream oos = null; try &#123; fos = new FileOutputStream(file); oos = new ObjectOutputStream(fos); oos.writeObject(stu); oos.flush(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; try &#123; oos.close(); fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void deserialization(String Path)&#123; File file = new File(Path); FileInputStream fis = null; ObjectInputStream ois = null; try &#123; fis = new FileInputStream(file); ois = new ObjectInputStream(fis); Student stu = (Student) ois.readObject(); System.out.println(stu); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;finally&#123; try &#123; ois.close(); fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"访问修饰符","slug":"访问修饰符","permalink":"http://example.com/tags/%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/"}]},{"title":"CSStransform","slug":"csstransform","date":"2021-04-12T15:16:20.000Z","updated":"2021-05-18T07:06:12.049Z","comments":true,"path":"2021/04/12/csstransform/","link":"","permalink":"http://example.com/2021/04/12/csstransform/","excerpt":"","text":"在CSS3中，可以利用transform功能来实现文字或图像的旋转、扭曲、缩放、位移、矩阵、原点这六种类型的变形处理，下面将详细讲解transform的使用。 变形–旋转 rotate() CSS 1div.box&#123;transform: rotate(45deg);&#125; 顺时针旋转45度 变形–扭曲 skew() CSS 1div.box&#123;transform:skew(45deg);&#125; 通过skew（）函数将长方形变成平行四边形。 Skew()具有三种情况： 1、skew(x,y)使元素在水平和垂直方向同时扭曲（X轴和Y轴同时按一定的角度值进行扭曲变形） 2、skewX(x)仅使元素在水平方向扭曲变形（X轴扭曲变形） 3、skewY(y)仅使元素在垂直方向扭曲变形（Y轴扭曲变形） 变形–缩放 scale() CSS 1div.box&#123;transform: scale(1.5,0.5);&#125; 缩放 scale 具有三种情况： 1、 scale(X,Y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放） 2、scaleX(x)元素仅水平方向缩放（X轴缩放） 3、scaleY(y)元素仅垂直方向缩放（Y轴缩放） scale()的取值默认的值为1，当值设置为0.01到0.99之间的任何值，作用使一个元素缩小；而任何大于或等于1.01的值，作用是让元素放大。 变形–位移 translate() CSS 1div.box&#123;transform: translate(50px,100px);&#125; 通过translate()函数将元素向Y轴下方移动50px,X轴右方移动100px。 translate我们分为三种情况： 1、translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动） 2、translateX(x)仅水平方向移动（X轴移动） 3、translateY(Y)仅垂直方向移动（Y轴移动） 变形–矩阵 matrix () CSS 1div.box&#123;transform: matrix(1,0,0,1,100,100);&#125; matrix() 6个属性的意思的：第一个宽度比例1就是原大小，第二个是上下倾斜1就是2倍，2就是3倍，0就是不倾斜第三个是左右倾斜，数字和第二个一样的意思，第四个是高度比例1就是原大小，第五个是X方向的像素位移，X方向就是左右，第六个是Y方向的像素位移，X方向就是上下*/ 变形–原点 transform-origin CSS 1div.box&#123;transform-origin: left top;transform: rotate(45deg); &#125; 改变元素原点到左上角，然后进行顺时旋转45度。","categories":[{"name":"css","slug":"css","permalink":"http://example.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"transform","slug":"transform","permalink":"http://example.com/tags/transform/"}]},{"title":"异常","slug":"exception","date":"2021-03-25T03:13:20.000Z","updated":"2021-03-25T03:18:42.430Z","comments":true,"path":"2021/03/25/exception/","link":"","permalink":"http://example.com/2021/03/25/exception/","excerpt":"","text":"异常什么是异常？异常是指在程序的运行过程中所发生的不正常的事件，他会中断正在循行的程序 异常处理的5个关键字捕捉异常: try：执行可能产生的异常代码 catch：捕捉异常 finally：无论是否发生异常，代码总能执行(除非JVM停电System.exit(1)) 声明异常 throws:声明方法可能要抛出的异常 抛出异常 throw:手动抛出异常 使用try-catch块捕获异常，分为三种情况：第一种情况(没有异常)12345678public class method()&#123; try&#123; //代码块(这块区域不会产生异常) &#125;catch(异常类型 e)&#123; //对异常进行处理的代码块 &#125; //代码段&#125; 运行到try块里没有检查出异常代码则会不执行catch里的代码块。 第二种情况(出现异常)12345678910public class method()&#123; try&#123; //代码段1 //产生异常代码段2 //代码段3 &#125;catch(异常类型 e)&#123; //对异常进行处理的代码块4 &#125; //代码段5&#125; 异常是一种特殊的对象，类型为Java.lang.Exception或其子类 执行到try时候发现异常–产生异常对象–异常类型匹配—进入catch代码块—然后在执行try-catch后的代码 第三种情况(异常类型不匹配)12345678910public class method()&#123; try&#123; //代码段1 //产生异常代码段2 //代码段3 &#125;catch(异常类型 e)&#123; //对异常进行处理的代码块4 &#125; //代码段5&#125; 执行到try时候发现异常–产生异常对象–异常类型不匹配—程序中断运行 在try-catch块后加入finally块 是否发生异常都执行 不执行的唯一情况 声明异常(throws)throws声明某个方法可能抛出的各种异样，多个异常用逗号隔开。 抛出异常(throw)除了系统自动抛出异常外，有些问题需要程序员自行抛出异常 throw throws 生成并抛出异常 声明方法内抛出了异常 位于方法体内，可作为单独语句使用 必须跟在方法参数列表后面，不能单独使用 抛出一个异常对象，且只能是一个 声明抛出异常类型，可以跟多个异常 自定义异常当JDK中的异常类型不能满足程序的需要时，可以自定义异常类 使用自定义异常的步骤： 定义异常类(继承Throwable、继承Excepion或者RuntimeException) 编写构造方法，继承父类的实现 实例化自定义对象 使用throw抛出","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"Exception","slug":"Exception","permalink":"http://example.com/tags/Exception/"}]},{"title":"重写和重载","slug":"overriding","date":"2021-03-16T14:11:20.000Z","updated":"2021-03-16T14:11:28.930Z","comments":true,"path":"2021/03/16/overriding/","link":"","permalink":"http://example.com/2021/03/16/overriding/","excerpt":"","text":"方法的重写或方法的覆盖(overriding) 子类根据需求从父类继承的方法进行重新编写 重写时，可以用super.方法的方式来保留父类的方法 构造方法不能被重写 方法重写规则 方法名相同,参数列表相同 1234567891011121314151617//父类public class Father &#123; public void method1()&#123; System.out.println(&quot;父类的method1方法&quot;); &#125;&#125;//子类public class Son extends Father&#123; public void method1()&#123; System.out.println(&quot;子类的method1方法&quot;); &#125; public static void main(String[] args) &#123; Son son = new Son(); son.method1(); &#125;&#125; 输出：子类的method1方法 返回值类型相同或者是其子类 1234567891011121314151617181920//父类public class Father &#123; //方法返回值类型可以是自定义的数据类型 public Father method1()&#123; return new Father(); &#125;&#125;//子类public class Son extends Father&#123; //子类方法返回值类型可以是父类方法返回值类型的子类，也是方法重写 public Son method1()&#123; System.out.println(&quot;子类重写后的method1方法&quot;); return new Father(); &#125; public static void main(String[] args) &#123; Son son = new Son(); son.method1(); &#125;&#125; 输出：子类重写后的method1方法 访问权限不能严于父类 1234567891011121314151617181920//父类public class Father &#123; //子类重写方法不可以比父类方法访问权限小，可以扩大方法的访问权限 //子类方法只要访问权限不严于父类，就构成了方法重写 void method1()&#123; System.out.println(&quot;父类的method1方法&quot;); &#125;&#125;//子类public class Son extends Father&#123; public Son method1()&#123; System.out.println(&quot;子类重写后的method1方法&quot;); &#125; public static void main(String[] args) &#123; Son son = new Son(); son.method1(); &#125;&#125; 输出：子类重写后的method1方法 父类的静态方法不能被子类覆盖为静态方法，父类的非静态方法不能被子类覆盖为静态方法 12345678910111213141516171819//父类public class Father &#123; public static void method1()&#123; System.out.println(&quot;父类的静态method1方法&quot;) &#125;&#125;//子类public class Son extends Father&#123; //父类的静态方法不能被重写为非静态方法 //反之，父类的非静态方法也不能被重写为静态方法 public void method1()&#123; System.out.println(&quot;子类重写后的非静态method1方法&quot;); &#125; public static void main(String[] args) &#123; Son son = new Son(); son.method1(); &#125;&#125; 输出：报错 子类可以定义与父类同名的静态方法，以便在子类中隐藏父类的静态方法(注：静态方法中无法使用super) 123456789101112131415161718192021//父类public class Father &#123; public static void method1()&#123; System.out.println(&quot;父类的静态method1方法&quot;); &#125;&#125;//子类public class Son extends Father&#123; //在子类中可以定义和父类一模一样的静态方法 public static void method1()&#123; //在静态方法中不能使用super //super.method1(); Father.method1(); System.out.println(&quot;子类重写后的静态method1方法&quot;); &#125; public static void main(String[] args) &#123; Son son = new Son(); son.method1(); &#125;&#125; 输出： 父类的静态method1方法子类重写后的静态method1方法 父类的私有方法不能被子类覆盖 123456789101112131415161718//父类public class Father &#123; private void method1()&#123; System.out.println(&quot;父类的私有method1方法&quot;); &#125;&#125;//子类public class Son extends Father&#123; // 子类无法重写父类的private方法 public void method1()&#123; System.out.println(&quot;子类的私有method1方法&quot;); &#125; public static void main(String[] args) &#123; Son son = new Son(); son.method1(); &#125;&#125; 输出：子类的私有method1方法 不能抛出比父类方法跟多的异常 重载和重写的区别 比较项 位置 方法名 参数表 返回值 访问修饰符 方法重写 子类 相同 相同 相同或是其子类 不能比父类更严格 方法重载 同类 相同 不相同 无关 无关 方法重载：同一个类中同名不同参跟访问修饰符以及返回值类型无关的叫重载 方法重写：在父子类中同名同参，返回值可以和父类返回值相同，可以是子类，访问修饰符只要不严于父类就行。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"overriding","slug":"overriding","permalink":"http://example.com/tags/overriding/"},{"name":"重写","slug":"重写","permalink":"http://example.com/tags/%E9%87%8D%E5%86%99/"},{"name":"重载","slug":"重载","permalink":"http://example.com/tags/%E9%87%8D%E8%BD%BD/"}]},{"title":"Java访问修饰符","slug":"java_public4","date":"2021-03-14T18:16:20.000Z","updated":"2021-03-25T03:31:52.736Z","comments":true,"path":"2021/03/15/java_public4/","link":"","permalink":"http://example.com/2021/03/15/java_public4/","excerpt":"","text":"类的访问控制符只能是空或者 public，方法和属性的访问控制符有 4 个，分别是 public、 private、protected 和 friendly，其中 friendly 是一种没有定义专门的访问控制符的默认情况。 类访问修饰符public修饰符：共有访问级别 默认修饰符：包级私有访问级别 在 Java 语言中，访问控制修饰符有 4 种。1. private用 private 修饰的类成员，只能被该类自身的方法访问和修改，而不能被任何其他类（包括该类的子类）访问和引用。 2. default（默认）如果一个类没有访问控制符，说明它具有默认的访问控制特性。这种默认的访问控制权规定，该类只能被同一个包中的类访问和引用，而不能被其他包中的类使用，即使其他包中有该类的子类。这种访问特性又称为包访问性（package private） 3. protected用保护访问控制符 protected 修饰的类成员可以被三种类所访问：该类自身、与它在同一个包中的其他类以及在其他包中的该类的子类。 4. public当一个类被声明为 public 时，它就具有了被其他包中的类访问的可能性，只要包中的其他类在程序中使用 import 语句引入 public 类，就可以访问和引用这个类。 Java支持四种不同的访问权限： 修饰符 说明 public 共有的，对所有类可见。 protected 受保护的，对同一包内的类和所有子类可见。 private 私有的，在同一类内可见。 默认的 在同一包内可见。默认不使用任何修饰符。 修饰符\\作用域 同一个类中 同一个包中 子类中 任何地方 privater 可以 不可以 不可以 不可以 默认修饰符\\default 可以 可以 不可以 不可以 protected 可以 可以 可以 不可以 public 可以 可以 可以 可以","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"访问修饰符","slug":"访问修饰符","permalink":"http://example.com/tags/%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/"}]},{"title":"Java中的Static","slug":"javastatic","date":"2021-03-14T18:16:20.000Z","updated":"2021-03-15T07:59:40.210Z","comments":true,"path":"2021/03/15/javastatic/","link":"","permalink":"http://example.com/2021/03/15/javastatic/","excerpt":"","text":"static修饰符 static是静态修饰符，主要作用在于创建独立于具体对象的域变量或者方法。 static可以用来修饰 成员变量 （静态变量，可以直接通过类名访问） 成员方法（静态方法，可以直接通过类名访问） 代码块（静态代码块，当Java虚拟机加载类时，就会执行该代码） static代码块jvm加载类时，加载静态代码块。 如果有多个静态块，按顺序加载。 每个静态代码块只会被执行一此。 代码1234567891011121314151617public class StaticTest &#123; static int num = 10; static&#123; num+=10; System.out.println(num); &#125; static&#123; num+=10; System.out.println(num); &#125; public static void main(String[] args) &#123; StaticTest s1 = new StaticTest(); StaticTest s2 = new StaticTest(); System.out.println(StaticTest.num); &#125;&#125; 运行结果： 203030 static变量类的成员变量包括类变量（静态变量） 被static修饰的变量。 在内存中只有一个拷贝。 类内部，可在任何地方直接访问静态变量。 其它类中，可以通过类名访问。 实例变量 没有被static修饰的变量。 每创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响。 static变量作用 能被类的所有实例共享，可作为实例之间进行交流的共享数据 如果类的所有实例都包含一个相同的常量属性，可把这个属性定义为静态常量类型，从而节省内存空间 123456789101112public class StaticTest &#123; static int num; public static void main(String[] args) &#123; num++; StaticTest s1 = new StaticTest(); s1.num++; StaticTest s2 = new StaticTest(); s2.num++; StaticTest.num++; System.out.println(num); &#125;&#125; 运行结果： 4 static方法静态方法：可直接通过类名访问 静态方法中不能使用this和super 不能直接访问所属类的实例变量和实例方法 可直接访问类的静态变量和方法 实例方法：通过实例访问 可直接访问所属类的静态变量、静态方法、实例变量和实例方法 静态方法必须被实现main()就是最常用的静态方法 常见错误static变量不能创建在方法里面 123456789101112131415161718192021222324252627282930/** * JVM加载类时,加载静态代码块 * 类内部,可在任何方法内直接访问静态变量; * 如果有多个静态代码块,按顺序执行 * 并且每个静态代码块只执行一次 */public class StaticText &#123; // TODO 在运行中 static会比实例变量更先运行出来 public StaticText()&#123; System.out.println(&quot;构造方法执行.....&quot;); &#125; static &#123; System.out.println(&quot;静态代码块执行....&quot;); &#125; // TODO 这三种有final 的会比上边static更先一步运行出来 因为final 单独已经存放在了内存地址里边, // 所以在没有创建类的情况下,有final 的已经存在于内存地址中 public static final String JD = &quot;jd&quot;; public String name = &quot;admin&quot;; public static String atr1 = &quot;atr1&quot;; public void method1()&#123; System.out.println(name); System.out.println(atr1); &#125; // TODO name 放到static中就会报错 因为static方法的速度快 在static起床时,实例变量还没有出生 // 所以实例变量在这个static方法中不起作用. public static void method2()&#123;// System.out.println(name);// System.out.println(atr1); &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"static","slug":"static","permalink":"http://example.com/tags/static/"}]},{"title":"冒泡排序","slug":"Bubble Sort","date":"2021-03-10T02:16:20.000Z","updated":"2021-03-10T02:33:41.416Z","comments":true,"path":"2021/03/10/Bubble Sort/","link":"","permalink":"http://example.com/2021/03/10/Bubble%20Sort/","excerpt":"","text":"Java冒泡排序 冒泡排序(Bubble Sort)是一种简单的排序方法。它重复的走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复的进行知道没有在需要叫唤，也就是说该数组已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 思路 比较相邻的元素。如果第一个比第二个大(或者小)，就交换他们两个。 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，知道没有任何一对数字需要比较。 代码12345678910111213141516public static void main(String[] ages)&#123; int[] nums = new int[] &#123;16,45,25,3,9,22,16,19,7,36&#125;; for (int i=0;i&lt;nums.length-1;i++)&#123; for (int j = 0; j&lt;nums.length-i-1;j++)&#123; if (nums[j]&gt;nums[j+1])&#123; int tepo = 0; tepo = nums[j+1] ; nums[j+1] = nums[j]; nums[j] = tepo; &#125; &#125; &#125; for (int i = 0; i&lt;nums.length;i++)&#123; System.out.print(nums[i]+&quot;\\t&quot;); &#125; &#125; 冒泡排序流程图 使用Arrays类进行排序代码123456789101112import java.util.Arrays;public class Demo1 &#123; public static void main(String[] ages)&#123; // TODO 使用Arrays类来进行数组排序。 int[] nums = new int[]&#123;6,8,3,7,9,1&#125;; //输出排序前的顺序 System.out.println(Arrays.toString(nums)); // 输出排序后的顺序 Arrays.sort(nums); System.out.println(Arrays.toString(nums)); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"冒泡","slug":"冒泡","permalink":"http://example.com/tags/%E5%86%92%E6%B3%A1/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java循环语句 for while doWhile","slug":"Javaxunhuan","date":"2021-01-27T12:16:20.000Z","updated":"2021-03-25T03:34:31.854Z","comments":true,"path":"2021/01/27/Javaxunhuan/","link":"","permalink":"http://example.com/2021/01/27/Javaxunhuan/","excerpt":"","text":"Java循环语句 for while doWhilefor循环语句for语法123 for(初始化表达式;判断表达式;递增（递减）表达式)&#123; 执行语句; //一段代码&#125; 参数 描述 for for 循环关键字，后面 {}里面是循环主体 初始化表达式 数字类型，判断条件中数字的初始值 判断表达式 条件语句，返回 boolean 类型，如果是 true 就执行方法体里面的语句 赋值增减量 对初值进行加减操作 for实例1234567891011public class Demofor2 &#123; public static void main(String[] args)&#123; System.out.print(&quot;请您输入一个值：&quot;); Scanner input = new Scanner(System.in); int num = input.nextInt(); int i,j; for (i=0, j=num; i&lt;num;i++,j--)&#123; System.out.println(i+&quot;+&quot;+j+&quot;=&quot;+num); &#125; &#125;&#125; 代码输出结果： while循环while语句说明while关键字的中文意bai思是du“当……的时候”，也就是当条件成立时循环执行对应的代码。while语句是循环语句中基本的结构，语法格式比较简单。 while语法123while(循环条件)&#123; //循环输出语句 &#125; while实例1234567891011121314public class Demowhile2 &#123; public static void main(String[] args)&#123; System.out.print(&quot;今天你的成绩合格了吗？(y/n)&quot;); Scanner input = new Scanner(System.in); String anu = input.next(); while(!&quot;y&quot;.equals(anu))&#123; System.out.println(&quot;上午学习理论！&quot;); System.out.println(&quot;下午上机编程！&quot;); System.out.print(&quot;今天你及格了吗？（y/n）&quot;); anu = input.next(); &#125; System.out.println(&quot;完成学习任务！&quot;); &#125;&#125; Do-while循环Do-while语法说明do-while是while的特殊种类，do-while会先运行一次do里的代码，然后进行while的Boolean判定，然后返回按照do里的方法重新运行。（先执行，后判断的while loop） Do-while语法1234do &#123; //循环体语句; //控制条件语句;&#125;while(判断条件语句); Do-while实例123456789101112public class DemoDowhile &#123; public static void main(String[] args)&#123; String jieGuo; do &#123; System.out.println(&quot;上机进行编程。&quot;); System.out.println(&quot;今天你及格了吗（y/n）&quot;); Scanner input = new Scanner(System.in); jieGuo = input.next(); &#125;while(!&quot;y&quot;.equals(jieGuo)); System.out.println(&quot;及格了就不用上机编程了。&quot;); &#125;&#125; 总结: 三种循环语句的区别:1.do…while循环至少执行一次循环体.2.而for,while循环必须先判断条件是否成立，然后决定是否执行循环体语句.3.for相对while和do-while来说相对简洁，判断方式和表达式只用写在一行就行.","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"循环语句","slug":"循环语句","permalink":"http://example.com/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"},{"name":"for","slug":"for","permalink":"http://example.com/tags/for/"},{"name":"while","slug":"while","permalink":"http://example.com/tags/while/"}]},{"title":"Java判断语句 If Switch","slug":"Javaifswitch","date":"2021-01-27T12:16:20.000Z","updated":"2021-03-25T03:34:09.004Z","comments":true,"path":"2021/01/27/Javaifswitch/","link":"","permalink":"http://example.com/2021/01/27/Javaifswitch/","excerpt":"","text":"Java判断语句If 和SwitchIf条件判断1、if语句用于判断不同的条件，根据判断的结果执行不同的代码。 2、if语句判断的条件可以是关系运算、逻辑运算，if语句根据逻辑值true、false来决定执行不同的代码。 3、if语句在开发中使用极为广泛。 If语法12345678 if（条件1) &#123; 代码块1 &#125; else if(条件2)&#123; 代码块2 &#125; &#125; else &#123; 代码块3&#125; If实例1234567891011121314public class Demoif &#123; public static void main(String[] str) &#123; System.out.print(&quot;请您输入您的考试成绩：&quot;); Scanner input = new Scanner(System.in); double chengJi = input.nextDouble(); if (chengJi&gt;=60 &amp; chengJi&lt;90)&#123; System.out.println(&quot;您的考试成绩合格！&quot;); &#125;else if (chengJi&gt;=90)&#123; System.out.println(&quot;您的考试成绩优异！&quot;); &#125;else&#123; System.out.println(&quot;您的成绩不及格，请您重新考试！&quot;); &#125; &#125;&#125; 在使用if语句时，注意尽量把容易满足的条件写在前面。 Switch条件判断Switch关键字1、switch：表示条件表达式，括号里的值是一个规定数据类型的值。 2、case：表示条件分支，case后面跟一个常量，每个case后面的值必须不一样。case的个数可以为0个。 3、default：表示默认分支，default可以省略，通常放在最后。 4、break：表示“停止”，跳出当前switch语句。 Switch语法1234567891011switch （表达式）&#123; case 常量1： // 代码块1; break; case 常量2： // 代码块2; break; default： // 代码块n; break;&#125; Switch实例1234567891011121314151617181920public class DemoSwitch &#123; public static void main(String args[]) &#123; System.out.print(&quot;请您输入您的名次：&quot;); Scanner input = new Scanner(System.in); int mingCi = input.nextInt(); switch(mingCi)&#123; case 1: System.out.println(&quot;恭喜您，获得了一等奖。&quot;); break; case 2: System.out.println(&quot;恭喜您，获得了二等奖。&quot;); break; case 3: System.out.println(&quot;恭喜您，获得了三等奖。&quot;); break; default: System.out.println(&quot;对不起，您没有进入前三名。&quot;); &#125; &#125;&#125; Switch语句中的表达式结果类型只支持是int，String，enum型的。 If和Switch的区别相同点： if和switch都是分支语句，都是对超过一种情况的事件进行处理。 不同点： switch更适合处理分支情况较多，判断条件类型单一，只有一个入口的事件if更适合处理分支情况较少，判断条件类型不是单一的事件 switch在分支执行完成后，如果没有break跳出的话，会继续向下面的分支执行if只要一个分支被执行了，后面的分支就不再执行了 switch为等值判断，不允许比如 &gt;= &lt;= 等判断if为等值和区间都可以，if的使用范围更大","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"判断语句","slug":"判断语句","permalink":"http://example.com/tags/%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5/"},{"name":"if Switch","slug":"if-Switch","permalink":"http://example.com/tags/if-Switch/"}]},{"title":"CSS伪类和伪元素的使用","slug":"cssweilei","date":"2021-01-13T03:13:58.000Z","updated":"2021-02-16T08:55:01.123Z","comments":true,"path":"2021/01/13/cssweilei/","link":"","permalink":"http://example.com/2021/01/13/cssweilei/","excerpt":"","text":"CSS伪类和伪元素的使用伪类 伪类： 一个伪类是我们可以为了增加CSS选择一个关键字定义一个特殊状态的属于HTML元素。我们可以使用冒号语法 将伪类添加到CSS选择器，:如下所示：a:hover{ … } 。 属性 描述 CSS :active 向被激活的元素添加样式。 1 :focus 向拥有键盘输入焦点的元素添加样式。 2 :hover 当鼠标悬浮在元素上方时，向元素添加样式。 1 :link 向未被访问的链接添加样式。 1 :visited 向已被访问的链接添加样式。 1 :first-child 向元素的第一个子元素添加样式。 2 :lang 向带有指定 lang 属性的元素添加样式。 2 :nth-child(2n) 向元素的偶数元素添加样式 a标记的伪类选择器123456789101112131415161718192021222324252627282930313233&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; /* 超链接为访问时的状态 */ a:link&#123; color: red; text-decoration: none; &#125; a&#123; font-size: 300px; &#125; /* 设置超链接访问过的网址状态 */ a:visited&#123; color: black; &#125; /*设置超链接鼠标悬停时候的样式 */ a:hover&#123; text-shadow: 5px 5px 5px #FF0000; &#125; /* 设置超链接单机未释放时候的样子 */ a:active&#123; color: lawngreen; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度一下&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 伪元素伪元素： css的伪元素，之所以被称为伪元素，是因为他们不是真正的页面元素，html没有对应的元素，但是其所有用法和表现行为与真正的页面元素一样，可以对其使用诸如页面元素一样的css样式，表面上看上去貌似是页面的某些元素来展现，实际上是css样式展现的行为，因此被称为伪元素。 属性 描述 CSS :first-letter 向文本的第一个字母添加特殊样式。 1 :first-line 向文本的首行添加特殊样式。 1 :before 在元素之前添加内容。 2 :after 在元素之后添加内容。 2 用于文本的:first-line 伪元素可以通过这个属性设置文本第一行的特殊效果，比如一段文字的第一行为红色，其他为黑色。 如果不通过这个方式来实现，就比较麻烦。因为屏幕适配的原因，你可能不能确定哪些文字属于第一行 :first-letter 伪元素和first-line 相似，这个只是设置第一个字符的特殊效果。比如第一个字的字体比别的大 如果不通过这个方式实现，那么就可能还要处理对齐，这种实现方式更方便 :before 和 :after伪元素使用12345678910111213141516171819202122232425262728&lt;title&gt;伪类&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; p&#123; width: fit-content; /* p标签的宽度随着文字内容长短而变化 */ &#125; p::before&#123; content: &#x27;&#x27;; /* 内容为空 */ height: 3px; background-color: yellow; display: block; &#125; p::after&#123; content: &#x27;&#x27;; height: 3px; background-color: red; display: block; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;文本文字&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"伪类和伪元素","slug":"伪类和伪元素","permalink":"http://example.com/tags/%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/"}]},{"title":"PHP连接MySQL数据库","slug":"php11-11","date":"2020-11-11T13:42:58.000Z","updated":"2021-01-27T13:33:10.980Z","comments":true,"path":"2020/11/11/php11-11/","link":"","permalink":"http://example.com/2020/11/11/php11-11/","excerpt":"PHP连接MySQL数据库1header(&#x27;Content-Type:text/html;charset=utf-8&#x27;);","text":"PHP连接MySQL数据库1header(&#x27;Content-Type:text/html;charset=utf-8&#x27;); //1 链接数据库1234567891011121314151617$host = &#x27;localhost&#x27;; //主机地址$user = &#x27;root&#x27;; //用户名$password = &#x27;123456&#x27;; //密码$database = &#x27;project5&#x27;; //数据库名称$port = 3306; //端口号$link = mysqli_connect($host, $user, $password, $database, $port); //链接MySQL//$link = new mysqli($host, $user, $password, $database, $port); //另外一种链接数据库语法//var_dump($link);//判断链接是否成功if($link)&#123;echo &#x27;链接成功！！！&#x27;;&#125;else&#123;echo &#x27;链接失败！！！&#x27;;&#125;; //2 执行SQL123456789mysqli_query($link,&#x27;set names utf8&#x27;);$sql = &#x27;select * from news&#x27;;$res = mysqli_query($link, $sql);mysqli_close($link); //关闭数据库//$sql = &#x27;update news set title=&quot;你好 中国&quot; where id=1&#x27;;//$res = mysqli_query($link, $sql);echo &#x27;&lt;pre&gt;&#x27;;//var_dump($res); //3 解析结果集 思考：每次取一行还是全取。123456//一行一行取所有数据 mysqli_fetch_row 索引数组 mysqli_fetch_assoc 关联数组// MYSQLI_BOTH 两者MYSQLI_ASSOC 关联 MYSQLI_NUM 索引//while($r = mysqli_fetch_array($res,MYSQLI_NUM))&#123;//// echo &quot;$r[1]====$r[2] ===== $r[3]&quot;,&quot;&lt;br&gt;&quot;;// var_dump($r);//&#125; 1234567// 一起取出来，然后在显示 $r = mysqli_fetch_all($res,MYSQLI_ASSOC);//var_dump($r);foreach($r as $v)&#123;// var_dump($v);echo $v[&#x27;title&#x27;].&#x27;&lt;br&gt;&#x27;;&#125; //4 关闭数据库1//mysqli_close($link);","categories":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/categories/PHP/"}],"tags":[{"name":"PHP代码","slug":"PHP代码","permalink":"http://example.com/tags/PHP%E4%BB%A3%E7%A0%81/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"MySQL数据库命令","slug":"mysql","date":"2020-11-05T12:35:58.000Z","updated":"2021-02-16T08:53:28.519Z","comments":true,"path":"2020/11/05/mysql/","link":"","permalink":"http://example.com/2020/11/05/mysql/","excerpt":"– 管理数据库– 1创建数据库1CREATE DATABASE t; – 2显示当前数据库 1SHOW DATABASES; – 3删除数据库 1DROP DATABASE t;","text":"– 管理数据库– 1创建数据库1CREATE DATABASE t; – 2显示当前数据库 1SHOW DATABASES; – 3删除数据库 1DROP DATABASE t; – 管理数据表– 创建数据表 12345CREATE TABLE stu1(id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT COMMENT &#39;学号&#39;,NAME VARCHAR(50) NOT NULL COMMENT &#39;姓名&#39;,age INT COMMENT &#39;年龄&#39;)ENGINE&#x3D;MYISAM DEFAULT CHARSET&#x3D;&#39;utf8&#39;; – 对数据表的数据处理：增 删 改 查– 增加数据 12INSERT INTO STU2(NAME,age) VALUES(&#39;王五&#39;,20),(&#39;李四&#39; ,20); – 删除数据 1DELETE FROM stu2 WHERE id &#x3D;3; – 修改数据 （设计一个标识例） 1UPDATE stu2 SET del &#x3D; &#39;1&#39; WHERE id&#x3D;4; – 查询操作– 1查询所以数据 123456SELECT * FROM stu2;SELECT id,NAME,age,del FROM stu2;SELECT NAME &#39;姓名&#39;,age &#39;年龄&#39; FROM stu2;SELECT DISTINCT NAME &#39;姓名&#39;,age &#39;年龄&#39; FROM stu2; – 2条件查询 1SELECT * FROM stu2 WHERE id&#x3D; 3; – 查年龄等于20或25的学生姓名 1SELECT * FROM stu2 WHERE age &#x3D; 20 OR age &#x3D;25; – 查询姓’张‘的学生信息 1SELECT * FROM stu2 WHERE NAME LIKE &#39;李%&#39;; – 排序 order by asc 升序（默认） desc 降序 1SELECT * FROM stu2 ORDER BY age; – 分组 group by– 是否删除 人数– 1 5– 0 2 1SELECT del &#39;是否删除&#39; , COUNT(*) &#39;人数&#39; FROM stu2 GROUP BY del;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL命令","slug":"MySQL命令","permalink":"http://example.com/tags/MySQL%E5%91%BD%E4%BB%A4/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"PHP验证码","slug":"php-1","date":"2020-10-14T15:21:41.000Z","updated":"2021-01-27T13:32:17.842Z","comments":true,"path":"2020/10/14/php-1/","link":"","permalink":"http://example.com/2020/10/14/php-1/","excerpt":"php实现验证码功能1一个长方形的底图；2验证码的内容（数字，数字+英文，中文）；3各色的干扰点；4长短颜色不一的干扰线段。验证码图是长方形的100*30的大小","text":"php实现验证码功能1一个长方形的底图；2验证码的内容（数字，数字+英文，中文）；3各色的干扰点；4长短颜色不一的干扰线段。验证码图是长方形的100*30的大小 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?php//创建验证码画布$img_w = 100; //验证码的宽度$img_h = 30; //验证码的高度$img = imagecreatetruecolor($img_w, $img_h); //创建画布$bg_color = imagecolorallocate($img,0xcc,0xcc,0xcc); //为画布分配颜色imagefill($img,0,0,$bg_color);$count = 4; //验证码位数$charset = &#x27;ABCDEFGHJKLMNPQRSTUVWXYZ23456789&#x27;; //随机因子$charset_len = strlen($charset)-1; //计算随机因子长度（作为取出时的索引）$code = &#x27;&#x27;; //保存生成的验证码for($i=0; $i&lt;$count; ++$i) &#123; //通过索引取出字符，mt_rand()用于获取指定范围内的随机数 $code .= $charset[mt_rand(0,$charset_len)];&#125;//在画布中绘制验证码文本$fontSize = 16; //文字大小$fontStyle = realpath(&#x27;./SourceCodePro-Bold.ttf&#x27;); //字体样式//生成指定长度的验证码for($i=0; $i&lt;$count; ++$i)&#123; //随机生成字体颜色 $fontColor = imagecolorallocate($img,mt_rand(0,100),mt_rand(0,50),mt_rand(0,255)); imagettftext ( $img, //画布资源 $fontSize, //文字大小 mt_rand(0,20) - mt_rand(0,25), //随机设置文字倾斜角度 $fontSize*$i+20,mt_rand($img_h/2,$img_h), //随机设置文字坐标，并自动计算间距 $fontColor, //文字颜色 $fontStyle, //文字字体 $code[$i] //文字内容 );&#125;//为验证码图片生成彩色噪点for($i=0; $i&lt;300; ++$i)&#123; //随机生成颜色 $color = imagecolorallocate($img,mt_rand(0,255),mt_rand(0,255),mt_rand(0,255)); //随机绘制干扰点 imagesetpixel($img,mt_rand(0,$img_w),mt_rand(0,$img_h),$color); &#125;$color = imagecolorallocate($img,mt_rand(0,255),mt_rand(0,255),mt_rand(0,255));imagerectangle($img, mt_rand(0,$img_h), mt_rand(0,$img_h), mt_rand(0,$img_h), mt_rand(0,$img_h), $color);imageellipse($img, mt_rand(0,$img_h), mt_rand(0,$img_h), 20, 20, $color); //绘制干扰线for($i=0; $i&lt;3; ++$i)&#123; //随机生成干扰线颜色 $color = imagecolorallocate($img,mt_rand(0,255),mt_rand(0,255),mt_rand(0,255)); //随机绘制干扰线 imageline($img,mt_rand(0,$img_w),0,mt_rand(0,$img_h*5),$img_h,$color);&#125;//将生成的文本保存到Session中session_start();$_SESSION[&#x27;captcha&#x27;] = $code;$fontfile =realpath(&#x27;SourceCodePro-Bold.ttf&#x27;);//imagettftext($img, 16, 0, 20, 30, $red, $fontfile, $code);//imagerectangle($canvas, 50, 50, 150, 150, $pink); header(&#x27;Content-Type: image/gif&#x27;);imagegif($img); ​ 源码里没有html代码","categories":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/categories/PHP/"}],"tags":[{"name":"PHP验证码","slug":"PHP验证码","permalink":"http://example.com/tags/PHP%E9%AA%8C%E8%AF%81%E7%A0%81/"}]},{"title":"Hexo博客发布文章","slug":"在这里","date":"2020-10-12T15:16:20.000Z","updated":"2021-01-27T13:26:21.862Z","comments":true,"path":"2020/10/12/在这里/","link":"","permalink":"http://example.com/2020/10/12/%E5%9C%A8%E8%BF%99%E9%87%8C/","excerpt":"1 创建文章12$ hexo new &quot;文章名&quot; &#x2F;&#x2F;安装hexo-asset-image后可使用 $ hexo n &quot;My New Post&quot; &#x2F;&#x2F;简写","text":"1 创建文章12$ hexo new &quot;文章名&quot; &#x2F;&#x2F;安装hexo-asset-image后可使用 $ hexo n &quot;My New Post&quot; &#x2F;&#x2F;简写 2 编辑文章12345678文章头部加---title: &#x2F;&#x2F;此处填写文章名date: &#x2F;&#x2F;此处填写发布日期tags: - &#x2F;&#x2F;此处填写标签名(可多个)categories: &#x2F;&#x2F;此处填写博客文章分类 3 文章添加图片 1 把本地Blog文件下的配置文件（非主题下）_config.yml里的post_asset_folder:选项设置为true 2 在本地Blog路径下执行npm install hexo-asset-image --save （用于下载安装一个可以上传本地图片的插件） 3 运行hexo n &quot;xxxx&quot;来生成md博文 会发现在/source/_posts文件夹中除了xxxx.md`文件还生成了一个同名文件夹 4最后在xxxx.md引入图片时，先把图片复制到xxxx文件夹中 然后在xxxx.md中按照markdown的格式引入图片： 1![你想输入的替代文字](xxxx&#x2F;图片名.jpg) 3 生产静态文件12$ hexo generate $ hexo g &#x2F;&#x2F;简写 5 启动本地服务器12$ hexo server $ hexo s &#x2F;&#x2F;简写 5 部署到远端站点12$hexo deploy $ hexo d &#x2F;&#x2F;简写","categories":[{"name":"博客","slug":"博客","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"CSS3中的flex布局","slug":"cssFlex","date":"2020-10-12T15:16:20.000Z","updated":"2021-05-18T06:59:19.989Z","comments":true,"path":"2020/10/12/cssFlex/","link":"","permalink":"http://example.com/2020/10/12/cssFlex/","excerpt":"","text":"flex是Flexible Box的缩写，意思为“弹性布局”，在使用过程中简单、易用、代码较少，在制作网页的时候经常使用这种方法来进行布局。 容器设置为flex以后，子元素的float、clear和vertcal-align的属性将失效。 1.box&#123;display:flex;&#125; 容器的六个属性flex-direction决定主轴的方向（即项目的排列方向） 123456.box&#123; display:flex; flex-direction:row; //默认值，主轴为水平方向，起点在左端。 flex-direction:row-reverse; //主轴为水平方向，起点在右端。 flex-direction:column; //主轴为垂直方向，起点在上沿。 flex-direction:column-reverse; //主轴为垂直方向，起点在下沿。&#125; flex-wrap定义如果一条轴线排不下，如何换行 123456.box&#123; display:flex; flex-wrap:nowrap; //默认值，不换行。 flex-wrap:wrap; //换行，第一行在上方。 flex-wrap:wrap-reverse; //换行，第一行在下方。&#125; flex-flow是flex-direction属性和flex-wrap属性的简写形式 1234.box&#123; display:flex; flex-flow:row nowrap; //默认值，不换行。&#125; justify-content属性定义了项目在主轴上的对齐方式。 12345678.box&#123; display:flex; justify-content:flex-start; //默认值，左对齐。 justify-content:flex-end; //右对齐。 justify-content:center; //水平居中。 justify-content:space-between; //两队对齐，项目之间间隔相等。 justify-content:space-around; //每个项目两侧间隔相等。&#125; align-items属性定义项目在交叉轴上如何对齐。 12345678.box&#123; display:flex; align-items:flex-start; //交叉轴的起点对齐。 align-items:flex-end; //交叉轴的终点对齐。 align-items:center; //垂直居中，交叉轴的中点对齐。 align-items:baseline; //项目第一行文字的基线对齐。 align-items:stretch; //默认值，项目未设置高度或设为auto，将占满整个容器的高度。&#125; align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123456789.box&#123; display:flex; align-content:flex-start; //与交叉轴的起点对齐。 align-content:flex-end; //与交叉轴的终点对齐。 align-content:center; //与交叉轴的中点对齐。 align-content:space-between; //与交叉轴两端对齐，轴线之间间隔平均分布。 align-content:space-between; //每根轴线两侧间隔相等。 align-content:stretch; //默认值，轴线占满交叉轴。&#125; 容器内元素6个属性flex-grow定义元素的放大比例，默认为0，即如果存在剩余空间，也不放大。 123 .box.item&#123; flex-grow:number(数字); //默认为0&#125; flex-shrink定义元素的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item&#123; flex-shrink:number(数字); //默认为0&#125; flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。 123.item&#123; flex-basis:length | auto; &#125; align-self允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。 12345678.item&#123; align-self:auto; align-self:flex-start; align-self:flex-end; align-self:center; align-self:baseline; align-self:stretch;&#125;","categories":[{"name":"css","slug":"css","permalink":"http://example.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"布局","slug":"布局","permalink":"http://example.com/tags/%E5%B8%83%E5%B1%80/"}]},{"title":"JavaScript常用基本语法","slug":"erye","date":"2020-10-11T18:03:01.000Z","updated":"2021-02-16T08:51:19.259Z","comments":true,"path":"2020/10/12/erye/","link":"","permalink":"http://example.com/2020/10/12/erye/","excerpt":"JavaScript中常用的语法和关键字。1.document.write(“”); 输出语句2.JS中的注释为//3.传统的HTML文档顺序是:document-&gt;html-&gt;(head,body)4.一个浏览器窗口中的DOM顺序是:window-&gt;(navigator,screen,history,location,document)","text":"JavaScript中常用的语法和关键字。1.document.write(“”); 输出语句2.JS中的注释为//3.传统的HTML文档顺序是:document-&gt;html-&gt;(head,body)4.一个浏览器窗口中的DOM顺序是:window-&gt;(navigator,screen,history,location,document) 5.得到表单中元素的名称和值:document.getElementById(“表单中元素的ID?”).name(或value)6.一个小写转大写的JS: document.getElementById(“output”).value = document.getElementById(“input”).value.toUpperCase();7.JS中的值类型:String,Number,Boolean,Null,Object,Function8.JS中的字符型转换成数值型:parseInt(),parseFloat()9.JS中的数字转换成字符型:(“” 变量)10.JS中的取字符串长度是:(length)11.JS中的字符与字符相连接使用 ?.12.JS中的比较操作符有:==等于,!=不等于,&gt;,&gt;=,&lt;.&lt;=13.JS中声明变量使用:var来进行声明14.JS中的判断语句结构:if(condition){}else{}15.JS中的循环结构:for([initial expression];[condition];[upadte expression]) {inside loop}16.循环中止的命令是:break17.JS中的函数定义:function functionName([parameter],…){statement[s]}18.当文件中出现多个form表单时.可以用document.forms[0],document.forms[1]来代替.19.窗口:打开窗口window.open(), 关闭一个窗口:window.close(), 窗口本身:self20.状?栏的设置:window.status=”字符”;21.弹出提示信息:window.alert(“字符”);22.弹出催认框:window.confirm();23.弹出输入提示框:window.prompt();24.指定当前显示链接的位置:window.location.href=”URL”25.取出窗体中的所有表单的数量:document.forms.length26.关闭文档的输出流:document.close();27.字符串追加连接符: =28.创建一个文档元素:document.createElement(),document.createTextNode()29.得到元素的方法:document.getElementById()30.设置表单中所有文本型的成员的值为空:var form = window.document.forms[0]for (var i = 0; i&lt;form.elements.length;i ){if (form.elements.type == “text”){form.elements.value = “”;}}31.复选按钮在JS中判断是否选中:document.forms[0].checkThis.checked (checked属性代表为是否选中返回TRUE或FALSE)32.单选按钮组(单选按钮的名称必须相同):取单选按钮组的长度document.forms[0].groupName.length33.单选按钮组判断是否被选中也是用checked.34.下拉列表框的值:document.forms[0].selectName.options[n].value (n有时用下拉列表框名称加上.selectedIndex来催定被选中的值)35.字符串的定义:var myString = new String(“This is lightsword”);36.字符串转成大写:string.toUpperCase(); 字符串转成小写:string.toLowerCase();37.返回字符串2在字符串1中出现的位置:String1.indexOf(“String2”)!=-1则说明没找到.38.取字符串中指定位置的一个字符:StringA.charAt(9);39.取出字符串中指定起点和终点的子字符串:stringA.substring(2,6);40.数学函数:Math.PI(返回圆周率),Math.SQRT2(返回开方),Math.max(value1,value2)返回两个数中的最在值,Math.pow(value1,10)返回value1的十次方,Math.round(value1)四舍五入函数,Math.floor(Math.random()*(n 1))返回胗机数41.定义日期型变量:var today = new Date();42.日期函数列表:dateObj.getTime()得到时间,dateObj.getYear()得到年份,dateObj.getFullYear()得到四位的年份,dateObj.getMonth()得到月份,dateObj.getDate()得到日,dateObj.getDay()得到日期几,dateObj.getHours()得到小时,dateObj.getMinutes()得到分,dateObj.getSeconds()得到秒,dateObj.setTime(value)设置时间,dateObj.setYear(val)设置年,dateObj.setMonth(val)设置月,dateObj.setDate(val)设置日,dateObj.setDay(val)设置星期几,dateObj.setHours设置小时,dateObj.setMinutes(val)设置分,dateObj.setSeconds(val)设置秒 [注意:此日期时间从0开始计]43.FRAME的表示方式: [window.]frames[n].ObjFuncVarName,frames[“frameName”].ObjFuncVarName,frameName.ObjFuncVarName44.parent代表父亲对象,top代表最顶端对象45.打开子窗口的父窗口为:opener46.表示当前所属的位置:this47.当在超链接中调用JS函数时用:(javascript :)来开头后面加函数名48.在老的浏览器中不执行此JS:49.引用一个文件式的JS:50.指定在不支持脚本的浏览器显示的HTML:51.当超链和onCLICK事件都有时,则老版本的浏览器转向a.html,否则转向b.html.例:dfsadf52.JS的?建对象有:Array,Boolean,Date,Error,EvalError,Function,Math,Number,Object,RangeError,ReferenceError,RegExp,String,SyntaxError,TypeError,URIError53.JS中的换行:\\n54.窗口全屏大小:function fullScreen(){ this.moveTo(0,0);this.outerWidth=screen.availWidth;this.outerHeight=screen.availHeight;}window.maximize=fullScreen;55.JS中的all代表其下层的全部元素56.JS中的焦点顺序:document.getElementByid(“表单元素”).tabIndex = 157.innerHTML的值是表单元素的值:如“how are you“,则innerHTML的值就是:how are you58.innerTEXT的值和上面的一样,只不过不会把这种?记显示出来.59.contentEditable可设置元素是否可被修改,isContentEditable返回是否可修改的状?.60.isDisabled判断是否为禁止状?.disabled设置禁止状?61.length取得长度,返回整型数值62.addBehavior()是一种JS调用的外部函数文件其扩展名为.htc63.window.focus()使当前的窗口在所有窗口之前.64.blur()指失去焦点.与FOCUS()相反.65.select()指元素为选中状?.66.防止用户对文本框中输入文本:onfocus=”this.blur()”67.取出该元素在页面中出现的数量:document.all.tags(“P(或其它HTML?记符)”).length68.JS中分为两种窗体输出:模?和非模?.window.showModaldialog(),window.showModeless()69.状?栏文字的设置:window.status=’文字’,默认的状?栏文字设置:window.defaultStatus = ‘文字.’;70.添加到收藏夹:external.AddFavorite(“”;,”webjx”);71.JS中遇到脚本错误时不做任何操作:window.onerror = doNothing; 指定错误句柄的语法为:window.onerror = handleError;72.JS中指定当前打开窗口的父窗口:window.opener,支持opener.opener…的多重继续.73.JS中的self指的是当前的窗口74.JS中状?栏显示?容:window.status=”?容”75.JS中的top指的是框架集中最顶层的框架76.JS中关闭当前的窗口:window.close();77.JS中提出是否催认的框:if(confirm(“Are you sure?”)){alert(“ok”);}else{alert(“Not Ok”);}78.JS中的窗口重定向:window.navigate();79.JS中的打印:window.print()80.JS中的提示输入框:window.prompt(“message”,”defaultReply”);81.JS中的窗口滚动条:window.scroll(x,y)82.JS中的窗口滚动到位置:window.scrollby83.JS中设置时间间隔:setInterval(“expr”,msecDelay)或setInterval(funcRef,msecDelay)或setTimeout84.JS中的模?显示在IE4 行,在NN中不行:showModalDialog(“URL”[,arguments][,features]);85.JS中的退出之前使用的句柄:function verifyClose(){event.returnValue=”we really like you and hope you will stay longer.”;}} window.=verifyClose;86.当窗体第一次调用时使用的文件句柄:onload()87.当窗体关闭时调用的文件句柄:onunload()88.window.location的属性: protocol(http:),hostname,port(80),host,pathname(“/a/a.html”),hash(“#giantGizmo”,指跳转到相应的锚记),href(全部的信息)89.window.location.reload()刷新当前页面.90.window.history.back()返回上一页,window.history.forward()返回下一页,window.history.go(返回第几页,也可以使用访问过的URL)91.document.write()不换行的输出,document.writeln()换行输出92.document.body.noWrap=true;防止链接文字折行.93.变量名.charAt(第几位),取该变量的第几位的字符.94.”abc”.charCodeAt(第几个),返回第几个字符的ASCii码值.95.字符串连接:string.concat(string2),或用 =进行连接96.变量.indexOf(“字符”,起始位置),返回第一个出现的位置(从0开始计算)97.string.lastIndexOf(searchString[,startIndex])最后一次出现的位置.98.string.match(regExpression),判断字符是否匹配.99.string.replace(regExpression,replaceString)替换现有字符串.100.string.split(分隔符)返回一个数组存储值.101.string.substr(start[,length])取从第几位到指定长度的字符串.102.string.toLowerCase()使字符串全部变为小写.103.string.toUpperCase()使全部字符变为大写.104.parseInt(string[,radix(代表进制)])强制转换成整型.105.parseFloat(string[,radix])强制转换成浮点型.106.isNaN(变量):测试是否为数值型.107.定义常量的关键字:const,定义变量的关键字:var","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"Typora编辑器","slug":"yige","date":"2020-10-11T05:40:49.000Z","updated":"2021-02-16T08:52:01.991Z","comments":true,"path":"2020/10/11/yige/","link":"","permalink":"http://example.com/2020/10/11/yige/","excerpt":"Typora编辑器好处下面是我觉得比较好的两个点： ①实时预览：在Typora中我们输入标记语法就能实时看到排版效果，解决了传统Markdown编辑器左右分屏式看起来麻烦的烦恼。 ②快捷键输入：很多标记语法我们都可以使用快捷键输入，免去了手动敲语法的烦恼。","text":"Typora编辑器好处下面是我觉得比较好的两个点： ①实时预览：在Typora中我们输入标记语法就能实时看到排版效果，解决了传统Markdown编辑器左右分屏式看起来麻烦的烦恼。 ②快捷键输入：很多标记语法我们都可以使用快捷键输入，免去了手动敲语法的烦恼。 常用快捷键和语法标题：Ctrl+1、2、3…对应一、二、三…级标题（光标定位到需要设置为标题的行，按快捷键） 加粗：Ctrl+B（选中要加粗的文本，按快捷键） 斜体：Ctrl+I（选中要设置斜体的文本，按快捷键） 下划线：Ctrl+U（选中要加下划线的文本，按快捷键） 删除线：Alt+Shift+5（选中要加删除线的文本，按快捷键） 代码片段：Ctrl+Shift+`（选中要设置为代码片段的文本，按快捷键） 代码块：Ctrl+Shift+K（任意位置按快捷键，选择编程语言然后在代码块中输入代码） 切换到下一行：Ctrl+Enter（任意位置按快捷键，在代码块中可以跳出代码块另起一行） 链接：Ctrl+K（先复制链接，然后选中要加链接的文本，按快捷键。Ctrl+左键点击文本可跳转到对应链接） 取消格式：再次按相同的快捷键即可 有序列表：数字+点+空格 任务列表：加号或减号+空格 切换到列表下一行：Space+Enter 嵌套列表：按Tab键 退出列表：按 Shift+Tab 插入表格：Ctrl+T 引用：输入&gt;后面加空格，或者Ctrl+Shift+Q","categories":[],"tags":[{"name":"编辑器","slug":"编辑器","permalink":"http://example.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"}]}],"categories":[{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"http://example.com/categories/Thymeleaf/"},{"name":"redis","slug":"redis","permalink":"http://example.com/categories/redis/"},{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"css","slug":"css","permalink":"http://example.com/categories/css/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/categories/CSS/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/categories/PHP/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"博客","slug":"博客","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/categories/JavaScript/"}],"tags":[{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"http://example.com/tags/Thymeleaf/"},{"name":"StringBoot","slug":"StringBoot","permalink":"http://example.com/tags/StringBoot/"},{"name":"语法","slug":"语法","permalink":"http://example.com/tags/%E8%AF%AD%E6%B3%95/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"},{"name":"SSM","slug":"SSM","permalink":"http://example.com/tags/SSM/"},{"name":"搭建","slug":"搭建","permalink":"http://example.com/tags/%E6%90%AD%E5%BB%BA/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://example.com/tags/Mybatis/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"page","slug":"page","permalink":"http://example.com/tags/page/"},{"name":"分页","slug":"分页","permalink":"http://example.com/tags/%E5%88%86%E9%A1%B5/"},{"name":"安装","slug":"安装","permalink":"http://example.com/tags/%E5%AE%89%E8%A3%85/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"centos7","slug":"centos7","permalink":"http://example.com/tags/centos7/"},{"name":"访问修饰符","slug":"访问修饰符","permalink":"http://example.com/tags/%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"transform","slug":"transform","permalink":"http://example.com/tags/transform/"},{"name":"Exception","slug":"Exception","permalink":"http://example.com/tags/Exception/"},{"name":"overriding","slug":"overriding","permalink":"http://example.com/tags/overriding/"},{"name":"重写","slug":"重写","permalink":"http://example.com/tags/%E9%87%8D%E5%86%99/"},{"name":"重载","slug":"重载","permalink":"http://example.com/tags/%E9%87%8D%E8%BD%BD/"},{"name":"static","slug":"static","permalink":"http://example.com/tags/static/"},{"name":"冒泡","slug":"冒泡","permalink":"http://example.com/tags/%E5%86%92%E6%B3%A1/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"循环语句","slug":"循环语句","permalink":"http://example.com/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"},{"name":"for","slug":"for","permalink":"http://example.com/tags/for/"},{"name":"while","slug":"while","permalink":"http://example.com/tags/while/"},{"name":"判断语句","slug":"判断语句","permalink":"http://example.com/tags/%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5/"},{"name":"if Switch","slug":"if-Switch","permalink":"http://example.com/tags/if-Switch/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"伪类和伪元素","slug":"伪类和伪元素","permalink":"http://example.com/tags/%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/"},{"name":"PHP代码","slug":"PHP代码","permalink":"http://example.com/tags/PHP%E4%BB%A3%E7%A0%81/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"},{"name":"MySQL命令","slug":"MySQL命令","permalink":"http://example.com/tags/MySQL%E5%91%BD%E4%BB%A4/"},{"name":"PHP验证码","slug":"PHP验证码","permalink":"http://example.com/tags/PHP%E9%AA%8C%E8%AF%81%E7%A0%81/"},{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"布局","slug":"布局","permalink":"http://example.com/tags/%E5%B8%83%E5%B1%80/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"编辑器","slug":"编辑器","permalink":"http://example.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"}]}